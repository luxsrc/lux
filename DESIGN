lux is designed around a simple but powerful module architecture.
Everything in lux is implemented as a module.  The lux core library,
libux, provides basic functions to access modules/plug-ins, to
construct numerical schemes, and to configure simulations.

INTERFACE: a lux interface Lux_MOD is simply a function type or a
  structure of function pointers that provides a type-safe way to
  access features in a lux module.  For example, a random number
  generator may have the following interface:

	typedef int (Lux_rand)(void); /* Lux_rand is not a pointer type */

  an input/output module that loads and dumps simulation data may have
  the following interface:

	typedef struct {
		void (*load)(Lux_sim *, const char *);
		void (*dump)(Lux_sim *, const char *);
	} Lux_io;

  This approach allows more than one implementation of the same
  interface.  A user can choose any implementation at run time:

	Lux_rand *rg = lux_load("rand", "nr"); /* numerical recipes version  */
	Lux_io   *io = lux_load("io",   ext);  /* ext can be "hdf5" or "vtk" */

  and the following function calls should work properly:

	int r = rg();
	io->load(sim, name);

  The lux interface Lux_MOD is defined in a header file MOD.h, which
  is placed in mod/ in the lux source tree, and is installed to
  $prefix/include/lux.

DYNAMIC MODULE: a lux module MOD is a dynamically loadable library
  that contains exactly one constructor

	void *LUXC(va_list);

  or, for one that does not require initialization, it needs to
  contain exactly one "entry symbol"

	Lux_MOD LUXE;

  which may be an exported function (e.g., of type Lux_rand in the
  previous section) or an exported structure (e.g., of type Lux_io)
  that provides the module interface.  The macros LUXC and LUXE expand
  to luxCMOD and to luxEMOD, respectively, to avoid symbol conflicts.
  When lux_load() access a module, it calls LUXC() to construct the
  interface or returns LUXE directly.  LUXC() may take care additional
  resource allocations.  In such a case, the lux module must implement
  a destructor:

	void LUXD(Lux_MOD *);

  which expands to luxDMOD, to release the allocated resource.  Note
  that chain-loading, i.e., using

	return lux_load(...);

  in a constructor, is allowed.  It works as expected because of the
  last-in-first-out nature of the stack used in the hash table.

  A lux module MOD is implemented in mod/ in the lux source tree, and
  is installed to $prefix/lib/lux.  In order to access dynamic
  modules, libux requires an external dynamic linker, which may make
  symbols from loaded modules globally accessible.  Therefore, module
  developers may want to put all the source code into a single file
  and define all private functions as static functions.  LUXC() or
  LUXE can then interface all of these static functions.  This is an
  ultimate way to avoid symbol conflicts because LUXC and LUXD, or
  LUXE, are the only exported symbols.

STATIC MODULE: sometimes it is overkill to pack some small functions
  into a dynamic lux module.  Calling functions via pointers can also
  reduce the performance.  Hence, we introduce the concept of "static
  modules", which are just header files that contain static inline
  functions and/or macros.

ERROR/FAILURE HANDLING: the terms "error" here refers to a recoverable
  and expected runtime error.  It is the type of errors typically
  handled by exceptions in object oriented languages such as C++ and
  Java.  Examples include "out of memory" by allocating memory and
  "permission denied" by opening a file.  It is not a programming bug
  that the developer can fixed.  However, ignoring such a runtime
  error in lux is considered a bug.  We use the term "failure" in lux
  for recoverable runtime errors to avoid confusions.

  In C, ad-hoc special values of the returned variable are used to
  indicate failures.  Once a failure is identified, the special global
  variable errno is checked to obtain the detail of the failure.  This
  overcomes the limitation that a C function can only return a single
  variable.  Usually, a message is then logged before other action is
  taken to resolve the failure:

	int fid = open(path, flag, mode);
	if(fid < 0) { /* handle failure */
		int err = errno;
		(void)fprintf(stderr,
		              "Failed to open \"%s\" [%d: %s]\n",
		              path, err, strerror(err));
		...
	}

  To avoid infinite recursion of failure logging, lux loggers never
  emit failure code themselves.  For other functions that can fail in
  lux, they often return pointers.  It is natural to employ the
  standard convention---the null pointer is an indication of failure
  and developers are expected to check for the failure code manually.

  lux enhances the standard <errno.h> mechanism by implement a static
  module <lux/failed.h>, where we define the following:

	#define failed errno

  The macro `failed`, expands to errno, is an lvalue and has type int,
  which is at least 16-bit in C.  The maximum defined system failure
  code (ELAST for BSD, ERFKILL for Linux on most architectures,
  _LAST_ERRNO for Linux/PowerPC and EDQUOT for Linux/MIPS, which are
  all unified as LUX_ELAST in lux) is usually only a few hundreds.
  Hence, we can encode additional information in `failed` to help
  handling failures.

  How many bits can we use to encode the additional information?  As
  far as we can tell, BSD-based systems has ELAST up to 106 (Darwin).
  For Linux, ERFKILL has value 132 on generic architectures.  It can
  take larger values on SPARC (134), Alpha (138), MIPS (167), and
  PARISC (256).  For Linux/PowerPC and Linux/MIPS, _LAST_ERRNO (516)
  and EDQUOT (1133) are the largest failure codes, respectively.  But
  since all these architectures are at least 32-bit, we can use 11
  bits to store their failure codes and use the remaining 21 bits to
  encode addition information.  Therefore, as long as we only
  guarantee 123 == 255 - 132 customized failed codes in lux, we can
  fit all the failure codes in 8 bits for 16-bit systems supported by
  Linux.  And we will have at least 8 bits to encode additional
  information.

  Clearly, failure handling in lux is tightly coupled to message
  logging (see next section).  lux reserves at least 1 bit to indicate
  if any failed message is attached to a failed code.

MESSAGE LOGGING: printing to stdout, stderr, files, or even memory are
  all consider message logging in lux.  They are coordinated by the
  single function

	lux_vlog(unsigned flag, const char *restrict format, va_list ap);

  There are 8 default flags that correspond to the standard syslog
  security levels or linux kernel log levels:

    level  | description                          | usage examples in lux
    -------+--------------------------------------+---------------------------
    emerg  | may crash or return wrong results    | bug found by assertion
    alert  | problem need to be fixed immediately | hardware failure
    crit   | critical error/exception condition   | library (e.g. MPI) failure
    err    | error/exception condition            | malloc failure
    warning| error may occur if no action is taken| low disk space
    notice | normal but significant condition     | excepted interrupt by user
    info   | normal operational message           | a sim has started
    debug  | print information for debugging      | name of called function

  These levels are preconfigured by bitwise-OR-ing a combination of
  following flags:

    LUX_LOG_SUSPEND    (1U << LUX_UNSIGNED_BIT - 1)
    LUX_LOG_FLAGS      (1U << LUX_UNSIGNED_BIT - 2)
    LUX_LOG_FATAL      (1U << LUX_UNSIGNED_BIT - 3)
    LUX_LOG_STREAM(ID) (1U << 5 + ID)
    LUX_LOG_STDOUT     (1U << 4)
    LUX_LOG_STDERR     (1U << 3)
    LUX_LOG_AUTOFORMAT (1U << 2)
    LUX_LOG_PID        (1U << 1)
    LUX_LOG_TIMESTAMP  (1U << 0)

  LUX_LOG_SUSPEND is the most significant bit.  This convention is
  chosen so that a level is suspended if and only if casting the level
  to an int results a negative number.

  LUX_LOG_FLAGS is the next significant bit.  When it is not set
  (flags & LUX_LOG_FLAGS == 0), all other bits are interpreted as an
  integer, which is an id linked by the current level.  Theoretically,
  we can keep track of 2^(sizeof(unsigned)*CHAR_BIT - 2) levels,
  although the actual number of allocated levels is 16 by default.

  When LUX_LOG_FLAGS is set, the following bit is LUX_LOG_FATAL, which
  tells if the message logger should abort the program.  The next
  LUX_UNSIGNED_BIT-6 bits are the bitwise-OR of log stream flags.
  Among them, the more significant (sizeof(unsigned)-1)*CHAR_BIT bits
  are for customizable output streams, while the least significant 2
  bits are reserved for stdout and stderr.  Usually, at least one of
  the stream flags is set.  In such a case, the least significant 3
  bits of flags set the behavior of the logger, and are interpreted as
  LUX_LOG_AUTOFORMAT, LUX_LOG_PID, and LUX_LOG_TIMESTAMP.  Otherwise,
  syslog() is used instead of any of the log stream and the least
  significant 3 bits are interpreted as a syslog severity level.

  The actual 16 levels are allocated as a mutable array so they are
  re-configurable at runtime.  In addition to the 8 default levels,
  the remaining 8 levels can be customized for other usages.  More
  levels can also be added by declaring unsigned variables to hold
  their properties.

  Some of the commonly used levels are mapped to the following
  convenience message logging functions:

    emerg -> lux_fatal()
    err   -> lux_error()
    info  -> lux_print()
    debug -> lux_debug()

  In addition to the above convenience functions, to help catching
  programming bugs, lux also provides a macro lux_assert() to mirror
  the function of assert() in <assert.h>.  The main difference between
  the two is that lux_assert() uses lux_vlog() and is customizable.
  Note that lux_assert() can be globally turned off at compile time by
  passing the "--disable-assertion" option to `./configure`.

CORE LIBRARY: the lux core library, libux, provides basic functions
  such as lux_load() and lux_unload() to access other lux modules/
  plug-ins, to construct numerical schemes, and to configure
  simulations.

  The lux executable provided within this software package is a
  lightweight frontend of the lux core library for Unix-like
  environments.  The full power of the lux framework can be easily
  used by and integrated to other codes by first calling lux_setup()
  to setup the lux environment and then linking them with

	gcc program.c -lux -o program

  In fact, this is the reason we chose "libux" as the core library
  name --- the name does not come from linux.
