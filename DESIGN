lux is designed around a simple but powerful module architecture.
Everything in lux is implemented as a module.  The lux core library,
libux, provides basic functions to access modules/plug-ins, to
construct numerical schemes, and to configure simulations.

INTERFACE: a lux interface Lux_MOD is simply a function type or a
  structure of function pointers that provides a type-safe way to
  access features in a lux module.  For example, a random number
  generator may have the following interface:

	typedef int (Lux_rand)(void); /* Lux_rand is not a pointer type */

  an input/output module that loads and dumps simulation data may have
  the following interface:

	typedef struct {
		void (*load)(Lux_sim *, const char *);
		void (*dump)(Lux_sim *, const char *);
	} Lux_io;

  This approach allows more than one implementation of the same
  interface.  A user can choose any implementation at run time:

	Lux_rand *rg = lux_load("rand", "nr"); /* numerical recipes version  */
	Lux_io   *io = lux_load("io",   ext);  /* ext can be "hdf5" or "vtk" */

  and the following function calls should work properly:

	int r = rg();
	io->load(sim, name);

  The lux interface Lux_MOD is defined in a header file MOD.h, which
  is placed in mod/ in the lux source tree, and is installed to
  $prefix/include/lux.

DYNAMIC MODULE: a lux module MOD is a dynamically loadable library
  that contains exactly one constructor

	void *LUXC(va_list);

  or, for one that does not require initialization, it needs to
  contain exactly one "entry symbol"

	Lux_MOD LUXE;

  which may be an exported function (e.g., of type Lux_rand in the
  previous section) or an exported structure (e.g., of type Lux_io)
  that provides the module interface.  The macros LUXC and LUXE expand
  to luxCMOD and to luxEMOD, respectively, to avoid symbol conflicts.
  When lux_load() access a module, it calls LUXC() to construct the
  interface or returns LUXE directly.  LUXC() may take care additional
  resource allocations.  In such a case, the lux module must implement
  a destructor:

	void LUXD(Lux_MOD *);

  which expands to luxDMOD, to release the allocated resource.  Note
  that chain-loading, i.e., using

	return lux_load(...);

  in a constructor, is allowed.  It works as expected because of the
  last-in-first-out nature of the stack used in the hash table.

  A lux module MOD is implemented in mod/ in the lux source tree, and
  is installed to $prefix/lib/lux.  In order to access dynamic
  modules, libux requires an external dynamic linker, which may make
  symbols from loaded modules globally accessible.  Therefore, module
  developers may want to put all the source code into a single file
  and define all private functions as static functions.  LUXC() or
  LUXE can then interface all of these static functions.  This is an
  ultimate way to avoid symbol conflicts because LUXC and LUXD, or
  LUXE, are the only exported symbols.

STATIC MODULE: sometimes it is overkill to pack some small functions
  into a dynamic lux module.  Calling functions via pointers can also
  reduce the performance.  Hence, we introduce the concept of "static
  modules", which are just header files that contain static inline
  functions and/or macros.

OPTIMIZATION: according to the README.hacks file in the fftw2 library,

    The architectural details of modern machines make performance
    *extremely* sensitive to little details such as where your code
    and data are placed in memory.

  It is therefore very difficult to develop a library with portable
  performance.  In lux, we follow fftw's approach to measure the wall
  clock time of different implementations of an algorithm, and select
  the fastest implementation dynamically.  Furthermore, lux provides a
  standard mechanism to make developing runtime optimizable algorithms
  more accessible to a wider range of computational scientists.

  At the lowest level, a runtime optimized algorithm can be executed
  by the following function call:

	selected_driver(state, parameters, input, output);

  where selected_driver is a pointer to a driver function or to the
  actual algorithm; state holds anything needed by the algorithm that
  would affect the performance (e.g., array stride, twiddle factors
  for FFT, pointers to more subroutines); parameters are inputs that
  would not affect performance (e.g., alpha in BLAS); and input and
  output are pointers to the storage data structures.

  In principle, we can pack parameters, input, and output into state.
  We call this a task in lux,

	typedef struct LuxStask {
		void (*exec)(struct LuxStask *);
		struct {
	 		...;
			struct { ... } paras;
			Lux_data *in, *out;
		} state;
	} Lux_task;

  which has a very simple and unified interface:

	task->exec(task);

  Although runtime optimization using a task can take into account,
  e.g., memory alignments of data structures, it requires creating new
  tasks to apply the same algorithm to different parameters and data
  sets.  This often makes the code harder to manage.  Moreover, the
  creation of additional tasks may sometimes be costly.  The fftw3
  library solves the second disadvantage by caching the measured
  performance with a hash table but this is overkill for lux.

  Instead, lux provides a more flexible and lightweight struct algo:

	typedef struct LuxSalgo {
		void (*exec)();
		struct {
	 		...;
		} state;
	} Lux_algo;

  where exec() takes different arguments according to the algorithm.
  For example, for in-place FFT, it is

	fft_inplace->exec(fft_inplace, array);

  and for semi-implicit Runge-Kutta stepping for the Navier-Stokes
  equations, it can be

	rk4->exec(rk4, dt, nu, curr, next);

  This approach mirrors the "new-array execute" functions in fftw3
  such as fftw_execute_dft() and fftw_execute_split_dft().

ERROR HANDLING: the term "error" in this section refers to a
  recoverable and expected runtime error.  It is the type of errors
  typically handled by exceptions in object oriented languages such as
  C++ and Java.  Examples include "out of memory" by allocating memory
  and "permission denied" by opening a file.  It is not a programming
  bug that the developer can fixed.  However, ignoring such a runtime
  error in lux is considered a bug.

  In C, ad-hoc special values of the returned variable are used to
  indicate errors.  Once an error is identified, the special global
  variable errno is checked to obtain the detail of the error.  This
  overcomes the limitation that a C function can only return a single
  variable.  Usually, a message is then logged before other action is
  taken to resolve the error:

	int fid = open(path, flag, mode);
	if(fid < 0) { /* handle error */
		int err = errno;
		(void)fprintf(stderr,
		              "Failed to open \"%s\" [%d: %s]\n",
		              path, err, strerror(err));
		...
	}

  To avoid infinite recursion of error logging, lux loggers never emit
  error themselves.  For other functions that can fail in lux, they
  often return pointers.  It is natural to employ the standard
  convention---the null pointer is an indication of error and
  developers are expected to check errno for the error code manually.

CORE LIBRARY: the lux core library, libux, provides basic functions
  such as lux_load() and lux_unload() to access other lux modules/
  plug-ins, to construct numerical schemes, and to configure
  simulations.

  The lux executable provided within this software package is a
  lightweight frontend of the lux core library for Unix-like
  environments.  The full power of the lux framework can be easily
  used by and integrated to other codes by first calling lux_setup()
  to setup the lux environment and then linking them with

	gcc program.c -lux -o program

  In fact, this is the reason we chose "libux" as the core library
  name --- the name does not come from linux.
